<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	
</body>
<script type="text/javascript">
<<<<<<< HEAD
	class Set {
		// 创建构造函数
		constructor() {
			this.items = {};
			// 记录集合中成员的数量
			this.size = 0;	
		}

		// has(val) 查看是否拥有该元素
		has(val) {
			// 每个对象都有的 hasOwnproperty(val)
			return this.items.hasOwnproperty(val);
		}

		// add(val) 添加一个元素
		add(val) {
			// 判断是否拥有该元素
			if (!this.has(val)) {
				this.items[val] = val;
				// 没添加一个元素，需要加一个
				this.size ++;
				return true;
			}
			// 如果该元素已经存在集合中
			return false;
		}

		// delete(val)	删除一个元素
		delete(val) {
			if (this.has(val)) {
				// 将items对象中的属性删除
				delete this.items[val];
				this.size --;
				return true;
			}
			return false;
		}

		// clear删除所有元素
		clear() {
			// 直接将items赋值为一个空对就可
			this.items = {};
			this.size = 0;
		}

		// keys() 方法 返回包含所有key的数组
		keys() {
			// 返回遍历集合的所有键名的数组
			return Object.keys(this.items);
		}

		// values 返回包含所有值的数组
		values() {
			return Object.values(this.items);
		}

		// forEach Set结构的键名就是键值
		forEach(fn, context) {
			for(let i = 0; i < this.items.length; i++) {
				let item = Object.keys(this.items)[i];
				fn.call(context, item, item, this.items);
			}
		}


		// 并集
		union(other) {
			let union = new Set();
			let values = this.values();
			for(let i = 0; i < values.length; i++) {
				union.add(values[i]);
			}
			// 将values重新赋值为新的集合
			values = other.values();
			for(let i = 0; i < values.length; i++) {
				union.add(values[i]);
			}

			return union;
		}

		// 交集
		intersect(other) {
			let intersect = new Set();
			let values = this.values();
			for(let i = 0; i < values.length; i++) {
				// 查看在other中是否存在
				if (other.has(values[i])) {
					// 存在 就往里面添加元素
					intersect.add(values[i]);
				}
			}
			return intersect;
		}

		// 差集	就是 A集合 - B集合
		different(other) {
			let different = new Set();
			let values = this.values();
			for(let i = 0; i < this.values.length; i++) {
				if (!other.has(values[i])) {
					different.add(values[i]);
				}
			}
			return different;
		}
	}

	// Map 	字典
	class Map {
		constructor() {
			this.items = {};
			this.size = 0;
		}

		// has
		has(key) {
			return this.items.hasOwnproperty(key);
		}

		// set(key, val), 当有相同的key时，会覆盖前一个值
		set(key, value) {
			tihs.items[key] = value;
			this.size ++;
		}

		// get 
		get(key) {
			// 判断是否有key，如果有就返回值，没有就返回undefined
			return this.has(key) ? this.items[key] : undefined;
		}

		// delete
		delete(key) {
			if (this.has(key)) {
				delete this.items[key];
				this.size --;
				return true;
			}
			return false;
		}

		clear() {
			this.items = {};
			this.size = 0;
		}

		// 遍历方法
		keys() {
			return Object.keys(this.items);
		}

		values() {
			return Object.values(this.items);
		}

		forEach(fn, context) {
			for(let i = 0; i < this.items.length; i++) {
				let key = Object.keys(this.items)[i];
				let value = Object.value(this.items)[i];
				fn.call(context, key, value, this.items);
			}
		}
=======
	try {
		console.log(1);
		console.log(1);
		console.log(1);
		console.log(1);
		console.log(1);
		console.log(1);
		let a = 2;
		try {
			let a = 3;
		} catch(err) {
			console.log('err:', err);
		}
	} catch(err) {
		console.log('err:', err);
>>>>>>> b45b02c0bb858f04c7f850df8ff6be9bb877b6f0
	}
</script>
</html>